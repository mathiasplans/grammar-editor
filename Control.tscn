[gd_scene load_steps=15 format=3 uid="uid://b05ly8tkkyqbc"]

[ext_resource type="Script" path="res://Root.gd" id="1"]
[ext_resource type="Script" path="res://EventPasser.gd" id="2"]
[ext_resource type="Texture2D" uid="uid://dgomoto7wxhcc" path="res://icons/unsynced.png" id="3"]
[ext_resource type="Script" path="res://Selector.gd" id="4"]
[ext_resource type="Script" path="res://AnchorManager.gd" id="5"]
[ext_resource type="Script" path="res://GrammarSymbolMaker.gd" id="6_j4m57"]

[sub_resource type="GDScript" id="GDScript_4jyo7"]
resource_name = "CompileButton"
script/source = "extends Button

const compiled_icon = preload(\"res://icons/compiled.png\")
const not_compiled_icon = preload(\"res://icons/unsynced.png\")

func _ready():
	%RuleManager.rule_edited.connect(_on_rule_edited)
	%RuleManager.rule_changed.connect(_on_rule_change)
	self.icon = self.not_compiled_icon

func _pressed():
	self.icon = self.compiled_icon

func _on_rule_edited():
	self.icon = self.not_compiled_icon
	
func _on_rule_change(_old_rule, _created):
	if %RuleManager.is_compiled():
		self.icon = self.compiled_icon
		
	else:
		self.icon  =self.not_compiled_icon
"

[sub_resource type="Environment" id="1"]
background_mode = 1
background_color = Color(1, 1, 1, 1)
ambient_light_color = Color(1, 1, 1, 1)
ambient_light_energy = 0.7

[sub_resource type="GDScript" id="GDScript_cq0kr"]
resource_name = "RuleManager"
script/source = "extends Node
class_name RuleManager

signal rule_changed(old_rule, created)
signal rule_edited

var _temp_shape
var rules = {}
var current_rule
var rule_i = 0

func _ready():
	# Setup for the default rule
	# Create a cube for now
	var cube = Cube.new(0.4)
	cube.original = true
	
	# Symbol handling
	cube.order_by_anchor(0, 1)
	var seed_sym = \"seed\"
	var sym = %Symbols.from_polyhedron(cube, seed_sym, false)
	cube.symbol = sym
	
	# Shape handling
	self._temp_shape = GrammarShape.new(sym, cube.vertices)
	
	# Connect signals
	$TreeManager.tree_edited.connect(self._edited)

func create_rule(index, shape : GrammarShape):
	var new_rule = Rule.new(index)
	
	var shape_poly = shape.get_polyhedron()
		
	new_rule.lhs = shape
	new_rule.lhs_poly = shape_poly

	# Tree handling
	$TreeManager.create_tree(new_rule, shape_poly)
	
	self.rules[index] = new_rule
	
	# Switch to new rule
	self.set_to_rule(index)
	
	return new_rule
	
func remove_rule(index):
	# Get a random other rule
	var keys = self.rules.keys()
	
	if not keys.has(index):
		return
		
	var new_index
	for key in keys:
		if key != index:
			new_index = key
			break
	
	# Change to that rule
	if new_index != null:
		self.set_to_rule(new_index)
		
	else:
		self.set_to_no_rule()
		pass
		
	var rule = self.rules[index]
	
	# Remove the reference from the symbol
	self.get_symbol().remove_rule(index)
	
	# Free the resources
	rule.queue_free()
	self.rules.erase(index)
	
func set_to_no_rule():
	var old_rule = self.current_rule
	self.current_rule = null
	self.rule_i = -1
	$TreeManager.remove_tree()
	
	self.rule_changed.emit(old_rule, false)

func set_to_rule(i):
	var replacement_rule = self.rules[i]
	var old_rule = self.current_rule
	self.current_rule = replacement_rule
	self.rule_i = i
	$TreeManager.set_tree(self.current_rule.split_tree)
	
	self.rule_changed.emit(old_rule, self.current_rule.is_empty())
	
func is_compiled():
	return self.current_rule != null and self.current_rule.compiled
	
func _edited():
	if self.current_rule != null:
		self.current_rule.compiled = false
		self.rule_edited.emit()
	
func get_lhs():
	return self.current_rule.lhs
	
func get_lhs_poly():
	return self.current_rule.lhs_poly
	
func get_symbol():
	return self._temp_shape.symbol
	
### Wrapper functions for the Tree Manager ###

func add_split(poly, cut_plane):
	$TreeManager.add_split(poly, cut_plane)
	self._edited()
	
func add_rotation(poly, rotation):
	$TreeManager.add_rotation(poly, rotation)
	self._edited()
	
func add_branch(cut, parent_treeitem, cut_plane, text, sym):
	$TreeManager.create_child_item(cut, parent_treeitem, cut_plane, text, sym)
	self._edited()
	
func compile():
	self.current_rule.compiled = true
	return $TreeManager.create_grammar_rule(self.current_rule.index)
	
### Wrapper functions for the Rule object ###

func set_meshes(poly, mesh_instances):
	self.current_rule.set_meshes(poly, mesh_instances)
	
	for mesh in mesh_instances:
		self.current_rule.add_child(mesh)
	
func get_meshes(poly):
	return self.current_rule.get_meshes(poly)
	
func erase_meshes(poly):
	for mesh in self.get_meshes(poly):
		self.current_rule.remove_child(mesh)
	
	self.current_rule.erase_meshes(poly)
		
func get_all_meshes():
	return self.current_rule.get_all_meshes()
	
func get_treeitem(poly):
	return self.current_rule.get_treeitem(poly)
	
func set_treeitem(poly, item):
	self.current_rule.set_treeitem(poly, item)
	
func set_leafness(poly):
	self.current_rule.set_leafness(poly)
	self._edited()
	
func remove_leafness(poly):
	self.current_rule.remove_leafness(poly)
	self._edited()
	
func is_leaf(poly):
	return self.current_rule.is_leaf(poly)
	
func add_cut(cut):
	self.current_rule.add_cut(cut)
	self._edited()
	
func get_leaf_polys():
	return self.current_rule.get_leaf_polys()

func add_anchor(poly, anchor):
	if self.get_anchor(poly) == null:
		self.current_rule.add_anchor(poly, anchor)
		self.current_rule.add_child(anchor)
		self._edited()
	
func remove_anchor(poly):
	var anchor = self.get_anchor(poly)
	
	if anchor != null:
		self.current_rule.remove_anchor(poly)
		self.current_rule.remove_child(anchor)
		self._edited()
	
func get_anchor(poly):
	return self.current_rule.get_anchor(poly)
"

[sub_resource type="GDScript" id="GDScript_xx60u"]
resource_name = "TreeManager"
script/source = "extends Node

signal tree_edited

const button_visible_tex = preload(\"res://icons/GuiVisibilityVisible.svg\")
const button_hidden_tex = preload(\"res://icons/GuiVisibilityHidden.svg\")
const button_epsilon = preload(\"res://icons/Greek_lc_epsilon.png\")
const button_epsilon_not = preload(\"res://icons/Greek_lc_epsilon_dis.png\")
const shape_icon = preload(\"res://icons/aneZtd-cube-cut-out.png\")
const compiled_icon = preload(\"res://icons/compiled.png\")
const not_compiled_icon = preload(\"res://icons/unsynced.png\")
const scissors_icon = preload(\"res://icons/scissors.png\")
const button_xray_tex = preload(\"res://icons/GuiVisibilityXray.svg\")

enum {NODE_POLY, NODE_SPLIT}
enum {TREE_TEXT, TREE_SYMBOL, tree_nr_of_cols, TREE_META = TREE_TEXT, TREE_BUTTONS = TREE_SYMBOL}
enum {BUTTON_EPSILON, BUTTON_HIDE, tree_nr_of_buttons}
enum {VIS_HIDDEN, VIS_XRAY, VIS_VISIBLE, VIS_amount}

var hidden_to_tex = {VIS_HIDDEN: button_hidden_tex, VIS_VISIBLE: button_visible_tex, VIS_XRAY: button_xray_tex}
var epsilon_to_tex = {true: button_epsilon, false: button_epsilon_not}

var current_tree

func _ready():
	%Editor/Selector.polyhedron_selected.connect(_on_polyhedron_selected)
	%Editor/Selector.polyhedron_deselected.connect(_on_polyhedron_deselect)

func _hidden_button_change(treeitem, tm):
	treeitem.set_button(TREE_BUTTONS, BUTTON_HIDE, hidden_to_tex[tm.hidden])
	
class TreeMeta:
	var poly = null
	var split = null
	var parent_split = null
	var hidden = VIS_VISIBLE
	var epsilon = false
	var leaf = true
	var other_hidden = VIS_VISIBLE
	
	var parent_indices = []
	var constructions = []
	
	var rotations = []
	
static func _treeitem_setup(item, metadata, text):
	item.add_button(TREE_BUTTONS, button_epsilon_not, BUTTON_EPSILON)
	item.add_button(TREE_BUTTONS, button_visible_tex, BUTTON_HIDE)
	
	item.set_metadata(TREE_META, metadata)
	item.set_text(TREE_TEXT, text)
	
	item.set_icon(0, shape_icon)
	
	item.set_editable(TREE_SYMBOL, true)
	
# Called when the node enters the scene tree for the first time.
func create_tree(rule, poly):
	# Temporary
	rule.split_tree = Tree.new()
	var new_tree = rule.split_tree
	
	rule.split_tree.columns = tree_nr_of_cols
	rule.split_root = new_tree.create_item()
	var tm = TreeMeta.new()
	tm.poly = poly
	
	for i in rule.lhs.symbol.nr_of_vertices:
		tm.parent_indices.push_back(i)

	rule.poly_to_treeitem[poly] = rule.split_root

	_treeitem_setup(rule.split_root, tm, \"A\")
	
	# Connect the signals
	rule.split_tree.button_clicked.connect(_on_tree_button)
	rule.split_tree.item_selected.connect(_on_tree_selected)
	rule.split_tree.item_edited.connect(_on_item_edited)

	return new_tree
	
func remove_tree():
	if self.current_tree != null:
		%TreeParent.remove_child(self.current_tree)
		
	self.current_tree = null
	
func set_tree(tree):
	if tree != null:
		if self.current_tree != null:
			%TreeParent.remove_child(self.current_tree)
		
		self.current_tree = tree
		%TreeParent.add_child(self.current_tree)
	
func create_child_item(cut, parent_poly, cut_plane, text, sym=null):
	var parent_treeitem = %RuleManager.get_treeitem(parent_poly)
	
	var poly = cut[0]
	var pos = cut[1]
	var construction = cut[2]
	
	# Set the symbol
	poly.symbol = sym
	
	# Add the new polyhedrons and the split to the tree
	var new_treeitem = self.current_tree.create_item(parent_treeitem)
	
	var tm = TreeMeta.new()
	tm.poly = poly
	tm.parent_split = cut_plane
	tm.parent_indices = pos
	tm.constructions = construction
	
	_treeitem_setup(new_treeitem, tm, text)
	
	%RuleManager.set_treeitem(poly, new_treeitem)
	%RuleManager.set_leafness(poly)
	
	self.tree_edited.emit()
	
func remove_leafness(poly):
	%RuleManager.remove_leafness(poly)
	var item = %RuleManager.get_treeitem(poly)
	
	var tm = item.get_metadata(TREE_META)
	tm.leaf = false
	
	# Change the icon
	item.set_icon(TREE_TEXT, scissors_icon)
	
	# Remove the epsilon button
	item.set_button_disabled(TREE_BUTTONS, BUTTON_EPSILON, true)
	
	self.tree_edited.emit()
	
func add_split(poly, split):
	var item = %RuleManager.get_treeitem(poly)
	var tm = item.get_metadata(TREE_META)
	tm.split = split
	
	self.tree_edited.emit()
	
func add_rotation(poly, rotation):
	var item = %RuleManager.get_treeitem(poly)
	var tm = item.get_metadata(TREE_META)
	tm.rotations.push_back(rotation)
	
	self.tree_edited.emit()

func _treeitem_set_visibility(item):
	var tm = item.get_metadata(TREE_META)
	if tm.leaf:
		var state = tm.hidden
		for m in %RuleManager.get_meshes(tm.poly):
			var t = false
			if (state == VIS_HIDDEN) or tm.epsilon:
				m.visible = false
				
			elif state == VIS_XRAY:
				# Make transparent
				t = true
				
				m.visible = true
				
			elif state == VIS_VISIBLE:
				m.visible = true
			
			var mat = m.get_active_material(0)	
			
			if t:
				mat.albedo_color.a = 0.2
				mat.flags_transparent = true
				m.disable_collision()
			
			else:
				mat.albedo_color.a = 1
				mat.flags_transparent = false
				m.enable_collision()

func _treeitem_visible(item, vis):
	var tm = item.get_metadata(TREE_META)
	tm.hidden = vis
	
	# Change the icon
	self._hidden_button_change(item, tm)
	
	if not tm.epsilon:	
		_treeitem_set_visibility(item)

		var children = item.get_children()
		for child in children:
			_treeitem_visible(child, vis)
			
func _treeitem_epsilonize(item, eps):
	var tm = item.get_metadata(TREE_META)
	tm.epsilon = eps
	
	_treeitem_set_visibility(item)
	
	item.set_button(TREE_BUTTONS, BUTTON_EPSILON, epsilon_to_tex[tm.epsilon])
	
	self.tree_edited.emit()

func _on_tree_button(item, column, id, _mouse_button_index):
	var tm = item.get_metadata(TREE_META)
	if column == TREE_BUTTONS:
		if id == BUTTON_HIDE:
			if Input.is_physical_key_pressed(KEY_SHIFT):
				if tm.other_hidden == VIS_XRAY:
					tm.other_hidden = VIS_VISIBLE
				
				else:
					tm.other_hidden = VIS_XRAY
				
				var parent = item.get_parent()
				
				while parent != null:
					var children = parent.get_children()
					for child in children:
						if child != item:
							self._treeitem_visible(child, tm.other_hidden)
							
					item = parent
					parent = parent.get_parent()

			else:
				self._treeitem_visible(item, (tm.hidden + 1) % VIS_amount)
			
		elif id == BUTTON_EPSILON:
			self._treeitem_epsilonize(item, not tm.epsilon)

func _on_tree_selected():
	var selected_item = self.current_tree.get_selected()
	var meta = selected_item.get_metadata(TREE_META)
	
	# Get one of the faces
	if %RuleManager.is_leaf(meta.poly):
		var face = %RuleManager.get_meshes(meta.poly)[0]
	
		# Select signal should be omited for the next selection
		%Editor/Selector.no_select_signal()
		%Editor/Selector.select_poly(face)
		
	else:
		pass
	
func _on_polyhedron_selected(poly, rule):
	var item = rule.get_treeitem(poly)
	item.select(TREE_TEXT)
	
func _on_polyhedron_deselect(poly, rule):
	var item = rule.get_treeitem(poly)
	item.deselect(TREE_TEXT)

# The goal is to unravel the tree, converting all the position
# and consturction indices into a global index space.
# 
# We know the original shape symbol, which is required for the creation of
# the rule. The symbol determines the first indices (they are the original indices).
# The indices after that have to be added recursively.
#
# The recursion step is as follows:
#  1. Get the map from polyhedrons indices to global indices
#  2. Translate the translations and constructions indices to global indices
#    - if an index does not exist, create it (GrammarRule::add_*_vertex)
#    - this new index should also be added to the global mapper
#  3. Repeat on the child, with parents global indices as the base for the position
#  4. At leaves, add productions
func _get_grammar_rule(item, parent_global_indices, rule_object):
	var tm = item.get_metadata(TREE_META)
	# If epsilon, do nothing
	if tm.epsilon:
		return
		
	# Get the rotation
	var vert_rotation = []
	for i in tm.poly.vertices.size():
		vert_rotation.push_back(i)
		
	for rot in tm.rotations:
		var new_rotation = []
	
		for new_i in rot.size():
			var old_i = rot[new_i]
			new_rotation.push_back(vert_rotation[old_i])
			
		vert_rotation = new_rotation
	
	# Get the global indices of the local poly
	var local_to_global = []
	for i in tm.parent_indices:
		# The vertex has to be constructed (a cut vertex)
		if tm.constructions.has(i):
			var inter_data = tm.constructions[i]
			var global_a = parent_global_indices[inter_data[0]]
			var global_b = parent_global_indices[inter_data[1]]
			var new_index = rule_object.add_interpolated_vertex(global_a, global_b, inter_data[2])
			local_to_global.push_back(new_index)
			pass
			
		# The vertex is inherited from the parent
		else:
			local_to_global.push_back(parent_global_indices[i])
			
	# Rotate the local vertices
	var rotated_local_to_global = []
	rotated_local_to_global.resize(local_to_global.size())
	Polyhedron._place(rotated_local_to_global, local_to_global, vert_rotation)
	
	# Recursion step
	var children = item.get_children()
	
	# Leaf case
	if children.size() == 0:
		# Get the symbol
		var sym = tm.poly.symbol
		
		# If the symbol does not exist, create a new one
		if sym == null:
			sym = %Symbols.from_polyhedron(tm.poly, \"_terminal\")
		
		# Add the production
		rule_object.add_product(sym, rotated_local_to_global)
	
	# Call for each child
	else:
		for child in children:
			_get_grammar_rule(child, rotated_local_to_global, rule_object)
	
func create_grammar_rule(index):
	var symbol = %RuleManager.get_symbol()
	
	var root_item = self.current_tree.get_root()
	var tm = root_item.get_metadata(TREE_META)
	var new_rule = GrammarRule.new(index, symbol)
	
	var indices = []
	for i in symbol.nr_of_vertices:
		indices.push_back(i)
	
	# Populate the rule with construction vertices
	self._get_grammar_rule(root_item, indices, new_rule)
	
	return new_rule

const _matching_sym_color = Color(0.3, 1, 0.1, 0.05)

# TODO: more locally near anchor manager
func _on_item_edited():
	var item = self.current_tree.get_edited()
	var new_text = item.get_text(TREE_SYMBOL)
	var tm = item.get_metadata(TREE_META)
	
	var old_sym = tm.poly.symbol

	# Does this symbol exist?
	if %Symbols.symbols.has(new_text):
		item.set_custom_bg_color(TREE_SYMBOL, _matching_sym_color)
		var sym = %Symbols.symbols[new_text]
		print(sym, \" \", old_sym)
		if sym != old_sym:
			tm.poly.symbol = sym

			var anchor_node = %Editor/AnchorManager.add_poly(tm.poly, sym)
			%RuleManager.add_anchor(tm.poly, anchor_node)
		
	# Change from a symbol to not symbol
	elif old_sym != null:
		item.clear_custom_bg_color(TREE_SYMBOL)
		tm.poly.symbol = null
		
		%Editor/AnchorManager.remove_poly(tm.poly)
		%RuleManager.remove_anchor(tm.poly)
"

[sub_resource type="GDScript" id="GDScript_hr8ly"]
resource_name = "Tester"
script/source = "extends Node3D

@onready var apply_rule = %ToolInfo/ApplyRule

var _shapes = []
var _terminals = []
var _shape_meshes = []
var _terminal_meshes = []

func _ready():
	self.apply_rule.button_down.connect(self._on_apply_rule_press)

static func _add_random_color(mesh_instances):
	var rng = RandomNumberGenerator.new()
	rng.randomize()
	
	for mesh_instance in mesh_instances:
		# Set color
		var col = Color(rng.randf_range(0.5, 1.0), rng.randf_range(0.5, 1.0), rng.randf_range(0.7, 1.0), 1.0)
		
		var mat = StandardMaterial3D.new()
		mat.albedo_color = col
			
		mesh_instance.set_surface_override_material(0, mat)


func _add_terminal(terminal_shape):
	self._terminals.push_back(terminal_shape)
	
	var _meshes = terminal_shape.get_meshes()
	var mesh_instances = []
	for mesh in _meshes:
		var new_inst = MeshInstance3D.new()
		new_inst.mesh = mesh
		mesh_instances.push_back(new_inst)
		
	_add_random_color(mesh_instances)
	
	for mi in mesh_instances:
		self._terminal_meshes.push_back(mi)
		self.add_child(mi)
		
func _clear_terminals():
	for tm in self._terminal_meshes:
		tm.queue_free()
		
	for t in self._terminals:
		t.free()
		
	self._terminal_meshes = []
	self._terminals = []

func _refresh_shapes():
	# Free the old shapes
	for sm in self._shape_meshes:
		sm.queue_free()
		
	self._shape_meshes = []
		
	# Add the new shape to the Tester
	for shape in self._shapes:
		var _meshes = shape.get_meshes()
		var mesh_instances = []
		for mesh in _meshes:
			var new_inst = MeshInstance3D.new()
			new_inst.mesh = mesh
			mesh_instances.push_back(new_inst)
			
		_add_random_color(mesh_instances)
		
		for mi in mesh_instances:
			self._shape_meshes.push_back(mi)
			self.add_child(mi)

# Fulfill a grammar
func _on_apply_rule_press():
	var new_shapes = []
	for shape in self._shapes:
		# Get the rule
		var grammar_rule = shape.symbol.select_rule()
		
		var shapes = grammar_rule.fulfill(shape)
		
		new_shapes.append_array(shapes)
	
	# Split the new array between shapes and terminals
	self._shapes = []
	for shape in new_shapes:
		if shape.symbol.is_terminal():
			self._add_terminal(shape)
			
		else:
			self._shapes.push_back(shape)
	
	self._refresh_shapes()

func _notification(what):
	if what == NOTIFICATION_VISIBILITY_CHANGED:
		self._on_visibility_changed()
		
func _is_inactive():
	return _shapes.size() == 0 and _terminals.size() == 0

func _on_visibility_changed():
	if self._is_inactive():
		var root_poly = %RuleManager.get_lhs_poly()
		
		var new_shape = GrammarShape.new(%RuleManager.get_symbol(), root_poly.vertices)
		self._shapes.push_back(new_shape)
		
		self._refresh_shapes()
		
	else:
		for shape in self._shapes:
			shape.free()
		
		self._shapes = []
		
		self._refresh_shapes()
		self._clear_terminals()
"

[sub_resource type="GDScript" id="GDScript_besah"]
resource_name = "Editor"
script/source = "extends Node3D
class_name Editor

@onready var compile_button = %ToolInfo/CompileButton
@onready var global_cut = %ToolInfo/GlobalCut

const button_visible_tex = preload(\"res://icons/GuiVisibilityVisible.svg\")
const button_hidden_tex = preload(\"res://icons/GuiVisibilityHidden.svg\")
const button_epsilon = preload(\"res://icons/Greek_lc_epsilon.png\")
const button_epsilon_not = preload(\"res://icons/Greek_lc_epsilon_dis.png\")
const shape_icon = preload(\"res://icons/aneZtd-cube-cut-out.png\")
const compiled_icon = preload(\"res://icons/compiled.png\")
const not_compiled_icon = preload(\"res://icons/unsynced.png\")
const scissors_icon = preload(\"res://icons/scissors.png\")
const button_xray_tex = preload(\"res://icons/GuiVisibilityXray.svg\")

enum {NODE_POLY, NODE_SPLIT}
enum {TREE_TEXT, TREE_SYMBOL, tree_nr_of_cols, TREE_META = TREE_TEXT, TREE_BUTTONS = TREE_SYMBOL}
enum {BUTTON_EPSILON, BUTTON_HIDE, tree_nr_of_buttons}
enum {VIS_HIDDEN, VIS_XRAY, VIS_VISIBLE, VIS_amount}

var hidden_to_tex = {VIS_HIDDEN: button_hidden_tex, VIS_VISIBLE: button_visible_tex, VIS_XRAY: button_xray_tex}
var epsilon_to_tex = {true: button_epsilon, false: button_epsilon_not}
	
func _update_compile_button():
	if %RuleManager.get_compiled():
		self.compile_button.icon = self.compiled_icon
	else:
		self.compile_button.icon = self.not_compiled_icon

static func _create_face_instances(poly):
	var mesh_instances = poly.get_face_objects()
	
	for mesh_instance in mesh_instances:
		# Add collision
		var mesh_area = Area3D.new()
		var mesh_colshape = CollisionShape3D.new()
		var colshape = ConcavePolygonShape3D.new()
		
		var polygons = mesh_instance.mesh.get_faces()
		colshape.set_faces(polygons)
		mesh_colshape.set_shape(colshape)
		
		# Set up the hierarchy
		mesh_area.add_child(mesh_colshape)
		mesh_instance.add_child(mesh_area)
		
		# Name the mesh area
		mesh_area.name = \"Area3D\"
		mesh_colshape.name = \"Colshape\"
		
		# Set needed attributes
		mesh_area.input_ray_pickable = true
		
	return mesh_instances

static func _add_random_color(mesh_instances):
	var rng = RandomNumberGenerator.new()
	rng.randomize()
	
	for mesh_instance in mesh_instances:
		# Set color
		var col = Color(rng.randf_range(0.5, 1.0), rng.randf_range(0.5, 1.0), rng.randf_range(0.7, 1.0), 1.0)
		
		var mat = StandardMaterial3D.new()
		mat.albedo_color = col
			
		mesh_instance.set_surface_override_material(0, mat)

func _mount_poly(poly):
	var mesh_instances = _create_face_instances(poly)
	_add_random_color(mesh_instances)
	
	for mesh_instance in mesh_instances:
		mesh_instance.create_cut.connect(self._on_create_cut)
		
	return mesh_instances

func poly_to_meshes(poly):
	var mesh_instances = self._mount_poly(poly)
	%RuleManager.set_meshes(poly, mesh_instances)
	
func draw_rule():
	if %RuleManager.current_rule != null:
		$Meshes.add_child(%RuleManager.current_rule)
		self.compile_button.disabled = false
		
	else:
		self.compile_button.disabled = true
	
func go_blank():
	self.compile_button.disabled = true
	
# Called when the node enters the scene tree for the first time.
func _ready():
	self.compile_button.button_down.connect(_on_compile_button_press)
	
	# Anchor manager
	$AnchorManager.polyhedron_reordered.connect(_on_poly_reorder)
	
	%RuleManager.rule_changed.connect(_on_rule_change)
	
	self.go_blank()
	
# Called when an event happens
func _input(event):
	# Undo and Redo mechanic. TODO: in root
	if event is InputEventKey:
		if event.pressed and event.keycode == KEY_Z and event.control:
			pass # TODO

# When a cut has been made, add the cutting plane
# mesh as a child and connect the 'cut_complete' signal
func _on_create_cut(cut_plane):
	# Register the cut for the shape TODO: do it in cut complete instead
	%RuleManager.add_cut(cut_plane)
	
	# Make the cut plane rotate with the poly
	%RuleManager.current_rule.add_child(cut_plane)
	
	# Subscribe to the cut completion callback
	cut_plane.cut_complete.connect(_on_cut_complete)

func _add_child_polyhedron(cut, parent_treeitem, cut_plane, text, sym=null):
	# Update the tree
	%RuleManager.add_branch(cut, parent_treeitem, cut_plane, text, sym)
	
	# Add new meshes
	var new_poly = cut[0]
	self.poly_to_meshes(new_poly)
	
func _cut_poly(cut_plane, poly):
	var cutdata = poly.cut(cut_plane.point(), cut_plane.normal)
	
	# No cut was made, do nothing
	if cutdata.size() == 1:
		# Flag the cut_plane to delete itself
		cut_plane.delete = true
		return

	# Free the old meshes
	%RuleManager.erase_meshes(poly)
	%RuleManager.remove_leafness(poly)
	
	if cut_plane.poly == poly:
		%RuleManager.add_split(poly, cut_plane)

	# Handle new polyhedrons
	var cut1 = cutdata[0]
	var cut2 = cutdata[1]
	
	self._add_child_polyhedron(cut1, poly, cut_plane, \"B\")
	self._add_child_polyhedron(cut2, poly, cut_plane, \"C\")

# On the cut completion, cut the polygon
func _on_cut_complete(cut_plane):
	if self.global_cut.button_pressed:
		var leaves = %RuleManager.get_leaf_polys().duplicate()
		for leaf in leaves:
			self._cut_poly(cut_plane, leaf)		
		
	else:
		self._cut_poly(cut_plane, cut_plane.poly)
	
	# Hide the cut
	cut_plane.visible = false
	
func _on_compile_button_press():
	var _grammar_rule = %RuleManager.compile()

func _on_poly_reorder(poly, new_order):
	# Remove old meshes
	%RuleManager.erase_meshes(poly)
	
	# Add new meshes
	self.poly_to_meshes(poly)
	
	# TODO: add the rotation info to the tree
	%RuleManager.add_rotation(poly, new_order)
	
func _on_rule_change(old_rule, created):
	# Orphan the old rule, if it exists
	if old_rule != null:
		$Selector.select_clear(null, old_rule)
		
		# This is important, otherwise will crash when trying to select
		# again
		old_rule.split_tree.deselect_all()
		
		# Remove all children of meshes
		$Meshes.remove_child(old_rule)
	
	# Create new meshes if the rule is new
	if created:
		var initial_poly = %RuleManager.get_lhs_poly()
		self.poly_to_meshes(initial_poly)

	# Add new meshes
	self.draw_rule()
"

[sub_resource type="GDScript" id="GDScript_1rxvp"]
resource_name = "NewRule"
script/source = "extends Button

@onready var rulesel_scene = preload(\"res://RuleSelector.tscn\")

var rule_index_counter = 0
	
func _pressed():
	var instance = rulesel_scene.instantiate()
	instance.rule_i = self.rule_index_counter
	self.rule_index_counter += 1
	
	var _new_rule = %RuleManager.create_rule(instance.rule_i, %RuleManager._temp_shape)
	
	%RuleSelectors.add_child(instance)

	var instance_i = instance.get_index()
	%RuleSelectors.move_child(instance, instance_i - 1)
	
	# Connect signals
	instance.rule_selected.connect(_on_rule_selected)
	instance.rule_deleted.connect(_on_rule_deleted)

func _on_rule_selected(rule_i):
	%RuleManager.set_to_rule(rule_i)
	
func _on_rule_deleted(rule_i):
	%RuleManager.remove_rule(rule_i)
"

[sub_resource type="GDScript" id="GDScript_s8l8w"]
resource_name = "ExplorerButton"
script/source = "extends Button

func _pressed():
	%Explorer.visible = not %Explorer.visible
"

[node name="Control" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1

[node name="HSplitContainer" type="HSplitContainer" parent="."]
custom_minimum_size = Vector2(1024, 600)
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="Left" type="VSplitContainer" parent="HSplitContainer"]
custom_minimum_size = Vector2(750, 0)
layout_mode = 2
size_flags_horizontal = 3

[node name="RuleEditor" type="VSplitContainer" parent="HSplitContainer/Left"]
layout_mode = 2
size_flags_vertical = 3

[node name="TopPanel" type="Panel" parent="HSplitContainer/Left/RuleEditor"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2
mouse_filter = 1

[node name="ToolInfo" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/TopPanel"]
unique_name_in_owner = true
layout_mode = 0
offset_right = 742.0
offset_bottom = 84.0
columns = 5

[node name="GlobalCut" type="CheckButton" parent="HSplitContainer/Left/RuleEditor/TopPanel/ToolInfo"]
layout_mode = 2
text = "Global Cut"

[node name="CompileButton" type="Button" parent="HSplitContainer/Left/RuleEditor/TopPanel/ToolInfo"]
layout_mode = 2
text = "Compile"
icon = ExtResource("3")
icon_alignment = 2
script = SubResource("GDScript_4jyo7")

[node name="TestGrammar" type="Button" parent="HSplitContainer/Left/RuleEditor/TopPanel/ToolInfo"]
layout_mode = 2
text = "Test"

[node name="ApplyRule" type="Button" parent="HSplitContainer/Left/RuleEditor/TopPanel/ToolInfo"]
layout_mode = 2
disabled = true
text = "New Gen"

[node name="SubViewportContainer" type="SubViewportContainer" parent="HSplitContainer/Left/RuleEditor"]
layout_mode = 2
size_flags_vertical = 3
stretch = true
script = ExtResource("2")

[node name="SubViewport" type="SubViewport" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer"]
handle_input_locally = false
physics_object_picking = true
size = Vector2i(840, 382)
render_target_update_mode = 4

[node name="Camera3D" type="Camera3D" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1.54398)
environment = SubResource("1")

[node name="Root" type="Node3D" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport"]
script = ExtResource("1")

[node name="RuleManager" type="Node" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root"]
unique_name_in_owner = true
script = SubResource("GDScript_cq0kr")

[node name="TreeManager" type="Node" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root/RuleManager"]
script = SubResource("GDScript_xx60u")

[node name="Tester" type="Node3D" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root"]
visible = false
script = SubResource("GDScript_hr8ly")

[node name="Editor" type="Node3D" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root"]
unique_name_in_owner = true
script = SubResource("GDScript_besah")

[node name="Selector" type="Node" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root/Editor"]
script = ExtResource("4")

[node name="AnchorManager" type="Node" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root/Editor"]
script = ExtResource("5")

[node name="Meshes" type="Node3D" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root/Editor"]

[node name="Symbols" type="Node" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport/Root"]
unique_name_in_owner = true
script = ExtResource("6_j4m57")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="HSplitContainer/Left/RuleEditor/SubViewportContainer/SubViewport"]
transform = Transform3D(0.656559, 0, 0.754274, 0, 1, 0, -0.754274, 0, 0.656559, 1.85974, 0, 0.65363)
light_energy = 0.3

[node name="VSplitContainer" type="VSplitContainer" parent="HSplitContainer/Left"]
layout_mode = 2
dragger_visibility = 2

[node name="Explorer" type="TabContainer" parent="HSplitContainer/Left/VSplitContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3

[node name="RulesContainer" type="ScrollContainer" parent="HSplitContainer/Left/VSplitContainer/Explorer"]
custom_minimum_size = Vector2(750, 120)
layout_mode = 2

[node name="RuleSelectors" type="GridContainer" parent="HSplitContainer/Left/VSplitContainer/Explorer/RulesContainer"]
unique_name_in_owner = true
layout_mode = 2
columns = 6

[node name="PanelContainer" type="PanelContainer" parent="HSplitContainer/Left/VSplitContainer/Explorer/RulesContainer/RuleSelectors"]
custom_minimum_size = Vector2(120, 70)
layout_mode = 2

[node name="Button" type="Button" parent="HSplitContainer/Left/VSplitContainer/Explorer/RulesContainer/RuleSelectors/PanelContainer"]
layout_mode = 2
text = "Seed
"

[node name="NewRuleContainer" type="PanelContainer" parent="HSplitContainer/Left/VSplitContainer/Explorer/RulesContainer/RuleSelectors"]
custom_minimum_size = Vector2(70, 70)
layout_mode = 2

[node name="Button" type="Button" parent="HSplitContainer/Left/VSplitContainer/Explorer/RulesContainer/RuleSelectors/NewRuleContainer"]
layout_mode = 2
text = "+"
script = SubResource("GDScript_1rxvp")

[node name="PanelContainer" type="PanelContainer" parent="HSplitContainer/Left/VSplitContainer"]
layout_mode = 2

[node name="HBoxContainer" type="HBoxContainer" parent="HSplitContainer/Left/VSplitContainer/PanelContainer"]
custom_minimum_size = Vector2(0, 25)
layout_mode = 2

[node name="ExplorerButton" type="Button" parent="HSplitContainer/Left/VSplitContainer/PanelContainer/HBoxContainer"]
layout_mode = 2
text = "Explorer"
script = SubResource("GDScript_s8l8w")

[node name="TreeParent" type="VSplitContainer" parent="HSplitContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
