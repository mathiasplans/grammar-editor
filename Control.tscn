[gd_scene load_steps=20 format=3 uid="uid://b05ly8tkkyqbc"]

[ext_resource type="Script" path="res://Root.gd" id="1"]
[ext_resource type="Script" path="res://ToolOpt.gd" id="1_ac0rl"]
[ext_resource type="Script" path="res://EventPasser.gd" id="2"]
[ext_resource type="Texture2D" uid="uid://dgomoto7wxhcc" path="res://icons/unsynced.png" id="3"]
[ext_resource type="Script" path="res://Selector.gd" id="4"]
[ext_resource type="Script" path="res://AnchorManager.gd" id="5"]
[ext_resource type="Script" path="res://GrammarSymbolMaker.gd" id="6_j4m57"]
[ext_resource type="Script" path="res://Cursors.gd" id="6_miobu"]

[sub_resource type="GDScript" id="GDScript_4jyo7"]
resource_name = "CompileButton"
script/source = "extends Button

const compiled_icon = preload(\"res://icons/compiled.png\")
const not_compiled_icon = preload(\"res://icons/unsynced.png\")

func _ready():
	%RuleManager.rule_edited.connect(_on_rule_edited)
	%RuleManager.rule_changed.connect(_on_rule_change)
	self.icon = self.not_compiled_icon

func _pressed():
	self.icon = self.compiled_icon

func _on_rule_edited(rule):
	if rule == %RuleManager.current_rule:
		self.icon = self.not_compiled_icon
	
func _on_rule_change(_old_rule, _created):
	if %RuleManager.is_compiled():
		self.icon = self.compiled_icon
		
	else:
		self.icon  =self.not_compiled_icon
"

[sub_resource type="GDScript" id="GDScript_wcrj7"]
script/source = "extends SpinBox

# This script only exists because the line edit does not
# relinquish the focus on submission

@onready var line = self.get_line_edit()

func _ready():
	self.line.text_submitted.connect(_on_text_submitted)
	
func _on_text_submitted(_new_text):
	self.line.release_focus()
"

[sub_resource type="Environment" id="1"]
background_mode = 1
background_color = Color(1, 1, 1, 1)
ambient_light_color = Color(1, 1, 1, 1)
ambient_light_energy = 0.7

[sub_resource type="GDScript" id="GDScript_cq0kr"]
resource_name = "RuleManager"
script/source = "extends Node
class_name RuleManager

signal rule_changed(old_rule, created)
signal rule_edited(rule)
signal symbol_displayed(symbol, display)

var current_symbol
var rules = {}
var current_rule
var rule_i = 0

# Persistant:
# * rules

func _ready():	
	# Connect signals
	$TreeManager.tree_edited.connect(self._edited)

func create_rule(symbol : GrammarSymbol, index):
	var new_rule = Rule.new(index)
	
	var shape = %Symbols.get_default_shape(symbol)
	var shape_poly = shape.get_polyhedron()
		
	new_rule.lhs = shape
	new_rule.lhs_poly = shape_poly

	# Tree handling
	$TreeManager.create_tree(new_rule, shape_poly)
	
	self.rules[[symbol, index]] = new_rule
	
	# Switch to new rule
	self.set_to_rule(symbol, index)
	
	return new_rule
	
func remove_rule(symbol, index):
	# Get a random other rule
	var keys = self.rules.keys()
	
	if not keys.has([symbol, index]):
		return
		
	var new_key
	for key in keys:
		if key[1] != index:
			new_key = key
			break
	
	# Change to that rule
	if new_key != null:
		self.set_to_rule(new_key[0], new_key[1])
		
	else:
		self.set_to_no_rule()
		pass
		
	var rule = self.rules[[symbol, index]]
	
	# Remove the reference from the symbol
	symbol.remove_rule(index)
	
	# Free the resources
	$TreeManager.delete_tree(rule.split_tree)
	rule.queue_free()
	self.rules.erase([symbol, index])
	
func get_rule():
	return self.current_rule
	
func set_to_no_rule():
	var old_rule = self.current_rule
	self.current_rule = null
	self.rule_i = -1
	$TreeManager.remove_tree()
	
	self.rule_changed.emit(old_rule, false)

func set_to_rule(symbol, index):
	var replacement_rule = self.rules[[symbol, index]]
	var old_symbol = self.current_symbol
	var old_rule = self.current_rule
	self.current_rule = replacement_rule
	self.rule_i = index
	self.current_symbol = symbol
	$TreeManager.set_tree(self.current_rule.split_tree)
	
	self.symbol_displayed.emit(old_symbol, false)
	self.rule_changed.emit(old_rule, self.current_rule.is_empty())
	
func set_to_symbol(symbol):
	var old_symbol = self.current_symbol
	var old_rule = self.current_rule
	self.current_rule = null
	self.rule_i = 0
	self.current_symbol = symbol
	$TreeManager.remove_tree()
	
	self.rule_changed.emit(old_rule, false)
	
	self.symbol_displayed.emit(old_symbol, false)
	self.symbol_displayed.emit(symbol, true)
	
func is_compiled():
	return self.current_rule != null and self.current_rule.compiled
	
func _edited(rule=self.current_rule):
	if rule != null:
		rule.compiled = false
		self.rule_edited.emit(rule)
	
func get_lhs():
	return self.current_rule.lhs
	
func get_lhs_poly():
	if self.current_rule == null:
		if self.current_symbol != null:
			var shape = %Symbols.get_default_shape(self.current_symbol)
			return shape.get_polyhedron()
			
		return null
		
	else:
		return self.current_rule.lhs_poly
	
func get_symbol():
	return self.current_symbol
	
### Wrapper functions for the Tree Manager ###

func add_split(poly, cut_plane):
	$TreeManager.add_split(poly, cut_plane)
	self._edited()
	
func add_rotation(poly, rotation):
	$TreeManager.add_rotation(poly, rotation)
	self._edited()
	
func add_branch(cut, parent_treeitem, cut_planes, text, sym):
	$TreeManager.create_child_item(cut, parent_treeitem, cut_planes, text, sym)
	self._edited()
	
func compile(rule=self.current_rule):
	rule.compiled = true
	return $TreeManager.create_grammar_rule(rule.index)
	
### Wrapper functions for the Rule object ###

func set_meshes(poly, mesh_instances, rule=self.current_rule):
	rule.set_meshes(poly, mesh_instances)
	
	for mesh in mesh_instances:
		rule.add_child(mesh)
	
func get_meshes(poly, rule=self.current_rule):
	return rule.get_meshes(poly)
	
func erase_meshes(poly, rule=self.current_rule):
	for mesh in self.get_meshes(poly):
		rule.remove_child(mesh)
	
	rule.erase_meshes(poly)
		
func get_all_meshes(rule=self.current_rule):
	return rule.get_all_meshes()
	
func get_treeitem(poly, rule=self.current_rule):
	return rule.get_treeitem(poly)
	
func set_treeitem(poly, item, rule=self.current_rule):
	rule.set_treeitem(poly, item)
	
func set_leafness(poly, rule=self.current_rule):
	rule.set_leafness(poly)
	self._edited(rule)
	
func remove_leafness(poly, rule=self.current_rule):
	rule.remove_leafness(poly)
	$TreeManager.remove_leafness(poly, rule)
	self._edited(rule)
	
func is_leaf(poly, rule=self.current_rule):
	return rule.is_leaf(poly)
	
func get_leaf_polys(rule=self.current_rule):
	return rule.get_leaf_polys()

func add_anchor(poly, anchor, rule=self.current_rule):
	if self.get_anchor(poly, rule) == null:
		rule.add_anchor(poly, anchor)
		rule.add_child(anchor)
		self._edited(rule)
	
func remove_anchor(poly, rule=self.current_rule):
	var anchor = self.get_anchor(poly, rule)
	
	if anchor != null:
		rule.remove_anchor(poly)
		rule.remove_child(anchor)
		self._edited(rule)
	
func get_anchor(poly, rule=self.current_rule):
	return rule.get_anchor(poly)

func get_polyhedrons(rule=self.current_rule):
	return rule.get_polyhedrons()
"

[sub_resource type="GDScript" id="GDScript_xx60u"]
resource_name = "TreeManager"
script/source = "extends Node

signal tree_edited

const button_visible_tex = preload(\"res://icons/GuiVisibilityVisible.svg\")
const button_hidden_tex = preload(\"res://icons/GuiVisibilityHidden.svg\")
const button_epsilon = preload(\"res://icons/Greek_lc_epsilon.png\")
const button_epsilon_not = preload(\"res://icons/Greek_lc_epsilon_dis.png\")
const shape_icon = preload(\"res://icons/aneZtd-cube-cut-out.png\")
const compiled_icon = preload(\"res://icons/compiled.png\")
const not_compiled_icon = preload(\"res://icons/unsynced.png\")
const scissors_icon = preload(\"res://icons/scissors.png\")
const button_xray_tex = preload(\"res://icons/GuiVisibilityXray.svg\")

enum {NODE_POLY, NODE_SPLIT}
enum {TREE_TEXT, TREE_SYMBOL, tree_nr_of_cols, TREE_META = TREE_TEXT, TREE_BUTTONS = TREE_SYMBOL}
enum {BUTTON_HIDE, BUTTON_EPSILON, BUTTON_CREATE_SYMBOL, tree_nr_of_buttons}
enum {VIS_HIDDEN, VIS_XRAY, VIS_VISIBLE, VIS_amount}

var hidden_to_tex = {VIS_HIDDEN: button_hidden_tex, VIS_VISIBLE: button_visible_tex, VIS_XRAY: button_xray_tex}
var epsilon_to_tex = {true: button_epsilon, false: button_epsilon_not}

var trees = []
var current_tree

var tree_symbols = {}
var tree_to_rule = {}

# Persistant:
# * trees
# * tree_symbols
# * tree_to_rule

func _ready():
	%Editor/Selector.polyhedron_selected.connect(_on_polyhedron_selected)
	%Editor/Selector.polyhedron_deselected.connect(_on_polyhedron_deselect)
	
	%Symbols.symbol_created.connect(_on_symbol_create)
	%Symbols.symbol_deleted.connect(_on_symbol_delete)
	%Symbols.symbol_renamed.connect(_on_symbol_rename)

func _hidden_button_change(treeitem, tm):
	var hide_index = treeitem.get_button_by_id(TREE_BUTTONS, BUTTON_HIDE)
	treeitem.set_button(TREE_BUTTONS, hide_index, hidden_to_tex[tm.hidden])

class TreeMeta:
	var poly = null
	var split = null
	var parent_split = null
	var hidden = VIS_VISIBLE
	var epsilon = false
	var leaf = true
	var other_hidden = VIS_VISIBLE
	var cut_type = Mode.NONE
	
	var parent_indices = []
	var constructions = []
	
	var rotations = []
	
# Persistant:
# * poly
# * split
# * parent_split
# * epsilon
# * leaf
# * cut-type
# * parent_indices
# * constructions
# * rotations
	
static func _treeitem_setup(item, metadata, text):
	item.add_button(TREE_BUTTONS, button_epsilon_not, BUTTON_EPSILON)
	item.add_button(TREE_BUTTONS, button_visible_tex, BUTTON_HIDE)
	
	item.set_metadata(TREE_META, metadata)
	item.set_text(TREE_TEXT, text)
	
	item.set_icon(0, shape_icon)
	
	item.set_editable(TREE_SYMBOL, true)
	
# Called when the node enters the scene tree for the first time.
func create_tree(rule, poly):
	# Temporary
	rule.split_tree = Tree.new()
	var new_tree = rule.split_tree
	
	rule.split_tree.columns = tree_nr_of_cols
	rule.split_root = new_tree.create_item()
	var tm = TreeMeta.new()
	tm.poly = poly
	
	for i in rule.lhs.symbol.nr_of_vertices:
		tm.parent_indices.push_back(i)

	rule.poly_to_treeitem[poly] = rule.split_root

	_treeitem_setup(rule.split_root, tm, \"A\")
	
	# Connect the signals
	rule.split_tree.button_clicked.connect(_on_tree_button)
	rule.split_tree.item_selected.connect(_on_tree_selected)
	rule.split_tree.item_edited.connect(_on_item_edited)

	self.trees.push_back(new_tree)
	self.tree_symbols[new_tree] = {}
	
	for symbol in %Symbols.get_symbols():
		self.tree_symbols[new_tree][symbol] = []
		
	self.tree_to_rule[new_tree] = rule

	return new_tree
	
func delete_tree(tree):
	self.tree_symbols.erase(tree)
	self.trees.erase(tree)
	tree.queue_free()
	
func remove_tree():
	if self.current_tree != null:
		%TreeParent.remove_child(self.current_tree)
		
	self.current_tree = null
	
func set_tree(tree):
	if tree != null:
		if self.current_tree != null:
			%TreeParent.remove_child(self.current_tree)
		
		self.current_tree = tree
		%TreeParent.add_child(self.current_tree)
	
func create_child_item(cut, parent_poly, cut_planes, text, sym=null):
	var parent_treeitem = %RuleManager.get_treeitem(parent_poly)
	
	var poly = cut[0]
	var pos = cut[1]
	var construction = cut[2]
	
	# Set the symbol
	poly.symbol = sym
	
	# Add the new polyhedrons and the split to the tree
	var new_treeitem = self.current_tree.create_item(parent_treeitem)
	
	var tm = TreeMeta.new()
	tm.poly = poly
	tm.parent_split = cut_planes
	tm.parent_indices = pos
	tm.constructions = construction
	
	_treeitem_setup(new_treeitem, tm, text)
	
	%RuleManager.set_treeitem(poly, new_treeitem)
	%RuleManager.set_leafness(poly)
	
	self.tree_edited.emit()
	
func remove_leafness(poly, rule):
	var item = %RuleManager.get_treeitem(poly, rule)
	
	var tm = item.get_metadata(TREE_META)
	tm.leaf = false
	
	# Change the icon
	item.set_icon(TREE_TEXT, scissors_icon)
	
	# Remove the epsilon button
	var index = item.get_button_by_id(TREE_BUTTONS, BUTTON_EPSILON)
	item.erase_button(TREE_BUTTONS, index)
	
	# Make the text non-editable
	item.set_editable(TREE_SYMBOL, false)
	
	if %RuleManager.current_rule == rule:
		self.tree_edited.emit()
	
func add_split(poly, split):
	var item = %RuleManager.get_treeitem(poly)
	var tm = item.get_metadata(TREE_META)
	tm.split = split
	tm.cut_type = split.cut_mode
	
	self.tree_edited.emit()
	
func add_rotation(poly, rotation):
	var item = %RuleManager.get_treeitem(poly)
	var tm = item.get_metadata(TREE_META)
	tm.rotations.push_back(rotation)
	
	self.tree_edited.emit()

func _treeitem_set_visibility(item):
	var tm = item.get_metadata(TREE_META)
	if tm.leaf:
		var state = tm.hidden
		for m in %RuleManager.get_meshes(tm.poly):
			var t = false
			if (state == VIS_HIDDEN) or tm.epsilon:
				m.visible = false
				
			elif state == VIS_XRAY:
				# Make transparent
				t = true
				
				m.visible = true
				
			elif state == VIS_VISIBLE:
				m.visible = true
			
			var mat = m.get_active_material(0)	
			
			if t:
				mat.albedo_color.a = 0.2
				#mat.flags_transparent = true
				m.disable_collision()
			
			else:
				mat.albedo_color.a = 1
				#mat.flags_transparent = false
				m.enable_collision()

func _treeitem_visible(item, vis):
	var tm = item.get_metadata(TREE_META)
	tm.hidden = vis
	
	# Change the icon
	self._hidden_button_change(item, tm)
	
	if not tm.epsilon:	
		_treeitem_set_visibility(item)

		var children = item.get_children()
		for child in children:
			_treeitem_visible(child, vis)
			
func _treeitem_epsilonize(item, eps):
	var tm = item.get_metadata(TREE_META)
	tm.epsilon = eps
	
	_treeitem_set_visibility(item)
	
	var epsilon_index = item.get_button_by_id(TREE_BUTTONS, BUTTON_EPSILON)
	item.set_button(TREE_BUTTONS, epsilon_index, epsilon_to_tex[tm.epsilon])
	
	self.tree_edited.emit()

func _on_tree_button(item, column, id, _mouse_button_index):
	var tm = item.get_metadata(TREE_META)
	if column == TREE_BUTTONS:
		if id == BUTTON_HIDE:
			if Input.is_physical_key_pressed(KEY_SHIFT):
				if tm.other_hidden == VIS_XRAY:
					tm.other_hidden = VIS_VISIBLE
				
				else:
					tm.other_hidden = VIS_XRAY
				
				var parent = item.get_parent()
				
				while parent != null:
					var children = parent.get_children()
					for child in children:
						if child != item:
							self._treeitem_visible(child, tm.other_hidden)
							
					item = parent
					parent = parent.get_parent()

			else:
				self._treeitem_visible(item, (tm.hidden + 1) % VIS_amount)
			
		elif id == BUTTON_EPSILON:
			self._treeitem_epsilonize(item, not tm.epsilon)
			
		elif id == BUTTON_CREATE_SYMBOL:
			var rule = %RuleManager.get_rule()
			self._on_item_edited(item)
			%AddSymbol.create_symbol(tm.poly, item.get_text(TREE_SYMBOL))
			self.anchor_update(item, rule)
			

func _on_tree_selected():
	var selected_item = self.current_tree.get_selected()
	var meta = selected_item.get_metadata(TREE_META)
	
	# Get one of the faces
	if %RuleManager.is_leaf(meta.poly):
		var face = %RuleManager.get_meshes(meta.poly)[0]
	
		# Select signal should be omited for the next selection
		%Editor/Selector.no_select_signal()
		%Editor/Selector.select_poly(face)
		
	else:
		pass
	
func _on_polyhedron_selected(poly, rule):
	var item = rule.get_treeitem(poly)
	item.select(TREE_TEXT)
	
func _on_polyhedron_deselect(poly, rule):
	var item = rule.get_treeitem(poly)
	item.deselect(TREE_TEXT)

# The goal is to unravel the tree, converting all the position
# and consturction indices into a global index space.
# 
# We know the original shape symbol, which is required for the creation of
# the rule. The symbol determines the first indices (they are the original indices).
# The indices after that have to be added recursively.
#
# The recursion step is as follows:
#  1. Get the map from polyhedrons indices to global indices
#  2. Translate the translations and constructions indices to global indices
#    - if an index does not exist, create it (GrammarRule::add_*_vertex)
#    - this new index should also be added to the global mapper
#  3. Repeat on the child, with parents global indices as the base for the position
#  4. At leaves, add productions
func _get_grammar_rule(item, parent_global_indices, rule_object):
	var tm = item.get_metadata(TREE_META)
	# If epsilon, do nothing
	if tm.epsilon:
		return
		
	# Get the rotation
	var vert_rotation = []
	for i in tm.poly.vertices.size():
		vert_rotation.push_back(i)
		
	for rot in tm.rotations:
		var new_rotation = []
	
		for new_i in rot.size():
			var old_i = rot[new_i]
			new_rotation.push_back(vert_rotation[old_i])
			
		vert_rotation = new_rotation
	
	# Construct new vertices.
	# This has to be done before the local_to_global because
	# some vertices that need to be constructed are not
	# in parent_indices.
	var cons = {}
	for i in tm.constructions:
		var inter_data = tm.constructions[i]
		
		var global_a
		var global_b
		
		if cons.has(inter_data[0]):
			global_a = cons[inter_data[0]]
				
		else:
			global_a = parent_global_indices[inter_data[0]]
			
		if cons.has(inter_data[1]):
			global_b = cons[inter_data[1]]
			
		else:
			global_b = parent_global_indices[inter_data[1]]
		
		var new_index = rule_object.add_interpolated_vertex(global_a, global_b, inter_data[2])
		cons[i] = new_index
	
	# Get the global indices of the local poly
	var local_to_global = []
	for i in tm.parent_indices:
		# The vertex has to be constructed (a cut vertex)
		if tm.constructions.has(i):
			var new_index = cons[i]
			local_to_global.push_back(new_index)
			
		# The vertex is inherited from the parent
		else:
			local_to_global.push_back(parent_global_indices[i])
			
	# Rotate the local vertices
	var rotated_local_to_global = []
	rotated_local_to_global.resize(local_to_global.size())
	Polyhedron._place(rotated_local_to_global, local_to_global, vert_rotation)
	
	# Recursion step
	var children = item.get_children()
	
	# Leaf case
	if children.size() == 0:
		# Get the symbol
		var sym = tm.poly.symbol
		
		# If the symbol does not exist, create a new one
		if sym == null:
			sym = %Symbols.from_polyhedron(tm.poly)
		
		# Add the production
		rule_object.add_product(sym, rotated_local_to_global)
	
	# Call for each child
	else:
		for child in children:
			_get_grammar_rule(child, rotated_local_to_global, rule_object)
	
func create_grammar_rule(index):
	var symbol = %RuleManager.get_symbol()
	
	var root_item = self.current_tree.get_root()
	var new_rule = GrammarRule.new(index, symbol)
	
	var indices = []
	for i in symbol.nr_of_vertices:
		indices.push_back(i)
	
	# Populate the rule with construction vertices
	self._get_grammar_rule(root_item, indices, new_rule)
	
	return new_rule

const _matching_sym_color = Color(0.3, 1, 0.1, 0.05)

func _remove_anchor(rule, treeitem, sym):
	var tm = treeitem.get_metadata(TREE_META)
	
	treeitem.clear_custom_bg_color(TREE_SYMBOL)
	tm.poly.symbol = null
	
	%Editor/AnchorManager.remove_poly(tm.poly)
	%RuleManager.remove_anchor(tm.poly, rule)

	if self.tree_symbols.has(self.current_tree):
		self.tree_symbols[self.current_tree][sym].erase(treeitem)

func anchor_update(item, rule=null):
	var new_text = item.get_text(TREE_SYMBOL)
	var tm = item.get_metadata(TREE_META)
	
	var old_sym = tm.poly.symbol

	# Does this symbol exist?
	if %Symbols.symbols.has(new_text):
		item.set_custom_bg_color(TREE_SYMBOL, _matching_sym_color)
		var sym = %Symbols.symbols[new_text]
		if sym != old_sym:
			tm.poly.symbol = sym

			var anchor_node = %Editor/AnchorManager.add_poly(tm.poly, sym)
			
			if rule == null:
				%RuleManager.add_anchor(tm.poly, anchor_node)
				self.tree_symbols[self.current_tree][sym].push_back(item)
				
			else:
				%RuleManager.add_anchor(tm.poly, anchor_node, rule)
				self.tree_symbols[rule.split_tree][sym].push_back(item)
		
		self.disable_create_symbol(item)
		
	# Change from a symbol to not symbol
	else:
		if old_sym != null:
			self._remove_anchor(%RuleManager.current_rule, item, old_sym)
		
		if new_text == \"\":
			self.disable_create_symbol(item)
			
		else:
			self.enable_create_symbol(item)

# TODO: more locally near anchor manager
func _on_item_edited(item=null):
	if item == null:
		item = self.current_tree.get_edited()

	self.anchor_update(item)
		
func enable_create_symbol(item):
	var index = item.get_button_by_id(TREE_BUTTONS, BUTTON_CREATE_SYMBOL)
	
	if index == -1:
		item.add_button(TREE_BUTTONS, self.shape_icon, BUTTON_CREATE_SYMBOL)

func disable_create_symbol(item):
	var index = item.get_button_by_id(TREE_BUTTONS, BUTTON_CREATE_SYMBOL)
	
	if index != -1:
		item.erase_button(TREE_BUTTONS, index)

func _on_symbol_create(symbol):
	for tree in self.trees:
		self.tree_symbols[tree][symbol] = []

func _on_symbol_delete(symbol):
	for tree in self.trees:
		var rule = self.tree_to_rule[tree]
		var items = self.tree_symbols[tree][symbol]
		
		for item in items:
			self._remove_anchor(rule, item, symbol)
			item.set_text(TREE_SYMBOL, \"\")
		
		self.tree_symbols[tree].erase(symbol)

func _on_symbol_rename(symbol, new_name):
	for tree in self.trees:
		var items = self.tree_symbols[tree][symbol]
		
		for item in items:
			item.set_text(TREE_SYMBOL, new_name)
"

[sub_resource type="GDScript" id="GDScript_hr8ly"]
resource_name = "Tester"
script/source = "extends Node3D

@onready var apply_rule = %ToolOpt/TestOpt/ApplyRule

var _shapes = []
var _terminals = []
var _shape_meshes = []
var _terminal_meshes = []

func _ready():
	self.apply_rule.button_down.connect(self._on_apply_rule_press)

static func _add_random_color(mesh_instances):
	var rng = RandomNumberGenerator.new()
	rng.randomize()
	
	for mesh_instance in mesh_instances:
		# Set color
		var col = Color(rng.randf_range(0.5, 1.0), rng.randf_range(0.5, 1.0), rng.randf_range(0.7, 1.0), 1.0)
		
		var mat = StandardMaterial3D.new()
		mat.albedo_color = col
			
		mesh_instance.set_surface_override_material(0, mat)


func _add_terminal(terminal_shape):
	self._terminals.push_back(terminal_shape)
	
	var _meshes = terminal_shape.get_meshes()
	var mesh_instances = []
	for mesh in _meshes:
		var new_inst = MeshInstance3D.new()
		new_inst.mesh = mesh
		mesh_instances.push_back(new_inst)
		
	_add_random_color(mesh_instances)
	
	for mi in mesh_instances:
		self._terminal_meshes.push_back(mi)
		self.add_child(mi)
		
func _clear_terminals():
	for tm in self._terminal_meshes:
		tm.queue_free()
		
	for t in self._terminals:
		t.free()
		
	self._terminal_meshes = []
	self._terminals = []

func _refresh_shapes():
	# Free the old shapes
	for sm in self._shape_meshes:
		sm.queue_free()
		
	self._shape_meshes = []
		
	# Add the new shape to the Tester
	for shape in self._shapes:
		var _meshes = shape.get_meshes()
		var mesh_instances = []
		for mesh in _meshes:
			var new_inst = MeshInstance3D.new()
			new_inst.mesh = mesh
			mesh_instances.push_back(new_inst)
			
		_add_random_color(mesh_instances)
		
		for mi in mesh_instances:
			self._shape_meshes.push_back(mi)
			self.add_child(mi)

# Fulfill a grammar
func _on_apply_rule_press():
	var new_shapes = []
	for shape in self._shapes:
		# Get the rule
		var grammar_rule = shape.symbol.select_rule()
		
		var shapes = grammar_rule.fulfill(shape)
		
		new_shapes.append_array(shapes)
	
	# Split the new array between shapes and terminals
	self._shapes = []
	for shape in new_shapes:
		if shape.symbol.is_terminal():
			self._add_terminal(shape)
			
		else:
			self._shapes.push_back(shape)
	
	self._refresh_shapes()

func _notification(what):
	if what == NOTIFICATION_VISIBILITY_CHANGED:
		self._on_visibility_changed()
		
func _is_inactive():
	return _shapes.size() == 0 and _terminals.size() == 0
	
var tools_vis = false
var tree_vis = false
var explorer_vis = false

func _on_visibility_changed():
	if self._is_inactive():
		var root_poly = %RuleManager.get_lhs_poly()
		
		var new_shape = GrammarShape.new(%RuleManager.get_symbol(), root_poly.vertices)
		self._shapes.push_back(new_shape)
		
		self._refresh_shapes()
		
		self.tools_vis = %ToolInfo.visible
		%ToolInfo.visible = false
		
		self.tree_vis = %TreeParent.visible
		%TreeParent.visible = false
		
		self.explorer_vis = %ExplorerButton.get_state()
		%ExplorerButton.close()
		
	else:
		for shape in self._shapes:
			shape.free()
		
		self._shapes = []
		
		self._refresh_shapes()
		self._clear_terminals()
		
		%ToolInfo.visible = self.tools_vis
		%TreeParent.visible = self.tree_vis
		%ExplorerButton.set_state(self.explorer_vis)
"

[sub_resource type="GDScript" id="GDScript_besah"]
resource_name = "Editor"
script/source = "extends Node3D
class_name Editor

@onready var compile_button = %RuleOpt/CompileButton
@onready var global_cut = %ToolOpt/FaceCutOpt/GlobalCut

const button_visible_tex = preload(\"res://icons/GuiVisibilityVisible.svg\")
const button_hidden_tex = preload(\"res://icons/GuiVisibilityHidden.svg\")
const button_epsilon = preload(\"res://icons/Greek_lc_epsilon.png\")
const button_epsilon_not = preload(\"res://icons/Greek_lc_epsilon_dis.png\")
const shape_icon = preload(\"res://icons/aneZtd-cube-cut-out.png\")
const compiled_icon = preload(\"res://icons/compiled.png\")
const not_compiled_icon = preload(\"res://icons/unsynced.png\")
const scissors_icon = preload(\"res://icons/scissors.png\")
const button_xray_tex = preload(\"res://icons/GuiVisibilityXray.svg\")

enum {NODE_POLY, NODE_SPLIT}
enum {TREE_TEXT, TREE_SYMBOL, tree_nr_of_cols, TREE_META = TREE_TEXT, TREE_BUTTONS = TREE_SYMBOL}
enum {BUTTON_EPSILON, BUTTON_HIDE, tree_nr_of_buttons}
enum {VIS_HIDDEN, VIS_XRAY, VIS_VISIBLE, VIS_amount}

var hidden_to_tex = {VIS_HIDDEN: button_hidden_tex, VIS_VISIBLE: button_visible_tex, VIS_XRAY: button_xray_tex}
var epsilon_to_tex = {true: button_epsilon, false: button_epsilon_not}
	
func _update_compile_button():
	if %RuleManager.get_compiled():
		self.compile_button.icon = self.compiled_icon
	else:
		self.compile_button.icon = self.not_compiled_icon

static func _create_face_instances(poly):
	var mesh_instances = poly.get_face_objects()
	
	for mesh_instance in mesh_instances:
		# Add collision
		var mesh_area = Area3D.new()
		var mesh_colshape = CollisionShape3D.new()
		var colshape = ConcavePolygonShape3D.new()
		
		var polygons = mesh_instance.mesh.get_faces()
		colshape.set_faces(polygons)
		mesh_colshape.set_shape(colshape)
		
		# Set up the hierarchy
		mesh_area.add_child(mesh_colshape)
		mesh_instance.add_child(mesh_area)
		
		# Name the mesh area
		mesh_area.name = \"Area3D\"
		mesh_colshape.name = \"Colshape\"
		
		# Set needed attributes
		mesh_area.input_ray_pickable = true
		
	return mesh_instances

static func _add_random_color(mesh_instances):
	var rng = RandomNumberGenerator.new()
	rng.randomize()
	
	for mesh_instance in mesh_instances:
		# Set color
		var col = Color(rng.randf_range(0.5, 1.0), rng.randf_range(0.5, 1.0), rng.randf_range(0.7, 1.0), 1.0)
		
		var mat = StandardMaterial3D.new()
		mat.albedo_color = col
		mat.transparency = true
			
		mesh_instance.set_surface_override_material(0, mat)

func _mount_poly(poly):
	var mesh_instances = _create_face_instances(poly)
	_add_random_color(mesh_instances)
	
	for mesh_instance in mesh_instances:
		mesh_instance.create_cut.connect(self._on_create_cut)
		
	return mesh_instances

func poly_to_meshes(poly):
	var mesh_instances = self._mount_poly(poly)
	%RuleManager.set_meshes(poly, mesh_instances)
	
func draw_rule():
	if %RuleManager.current_rule != null:
		$Meshes.add_child(%RuleManager.current_rule)
		self.compile_button.disabled = false
		%ToolInfo.visible = true
		
	else:
		self.compile_button.disabled = true
		%ToolInfo.visible = false
		
func draw_symbol():
	if %RuleManager.symbol != null:
		%ToolInfo.visible = false
	
func go_blank():
	self.compile_button.disabled = true
	
# Called when the node enters the scene tree for the first time.
func _ready():
	self.compile_button.button_down.connect(_on_compile_button_press)
	
	# Anchor manager
	$AnchorManager.polyhedron_reordered.connect(self._on_poly_reorder)
	
	%RuleManager.rule_changed.connect(self._on_rule_change)
	%RuleManager.symbol_displayed.connect(self._on_symbol_display)
	
	$Cursors.create_cut.connect(self._on_cut_complete)
	
	self.go_blank()
	
# Called when an event happens
func _input(event):
	# Undo and Redo mechanic. TODO: in root
	if event is InputEventKey:
		if event.pressed and event.keycode == KEY_Z and event.control:
			pass # TODO

# When a cut has been made, add the cutting plane
# mesh as a child and connect the 'cut_complete' signal
func _on_create_cut(cut_plane):
	# Make the cut plane rotate with the poly
	%RuleManager.current_rule.add_child(cut_plane)
	
	# Subscribe to the cut completion callback
	cut_plane.cut_complete.connect(_on_cut_complete)

func _add_child_polyhedron(cut, parent_treeitem, cut_planes, text, sym=null):
	# Update the tree
	%RuleManager.add_branch(cut, parent_treeitem, cut_planes, text, sym)
	
	# Add new meshes
	var new_poly = cut[0]
	self.poly_to_meshes(new_poly)
	
func _cut_poly(cut_planes, poly):
	var points = []
	var normals = []
	
	for cut_plane in cut_planes:
		points.push_back(cut_plane.point())
		normals.push_back(cut_plane.normal)
	
	var cutdata = poly.multi_cut(points, normals)
	
	# No cut was made, do nothing
	if cutdata.size() == 1:
		# Flag the cut_plane to delete itself
		for cut_plane in cut_planes:
			cut_plane.delete = true
			
		return

	# Free the old meshes
	%RuleManager.erase_meshes(poly)
	%RuleManager.remove_leafness(poly)
	
	for cut_plane in cut_planes:
		if cut_plane.poly == poly:
			%RuleManager.add_split(poly, cut_plane)

	# Handle new polyhedrons
	for cut in cutdata:
		self._add_child_polyhedron(cut, poly, cut_planes, \"B\")

# On the cut completion, cut the polygon
func _on_cut_complete(cut_planes, _poly):
	if self.global_cut.button_pressed:
		var leaves = %RuleManager.get_leaf_polys().duplicate()
		for leaf in leaves:
			self._cut_poly(cut_planes, leaf)
		
	elif _poly is Polyhedron:
		self._cut_poly(cut_planes, _poly)
		
	else:
		var leaves = %RuleManager.get_leaf_polys().duplicate()
		for leaf in leaves:
			var new_cut_planes = []
			for cut_plane in cut_planes:
				if leaf.intersects_face(cut_plane.hull):
					new_cut_planes.push_back(cut_plane)
					
			if new_cut_planes.size() > 0:
				self._cut_poly(new_cut_planes, leaf)
	
	# Hide the cut
	for cut_plane in cut_planes:
		cut_plane.visible = false
	
func _on_compile_button_press():
	var _grammar_rule = %RuleManager.compile()

func _on_poly_reorder(poly, new_order):
	# Remove old meshes
	%RuleManager.erase_meshes(poly)
	
	# Add new meshes
	self.poly_to_meshes(poly)
	
	# TODO: add the rotation info to the tree
	%RuleManager.add_rotation(poly, new_order)
	
func _on_rule_change(old_rule, created):
	# Orphan the old rule, if it exists
	if old_rule != null:
		$Selector.select_clear(null, old_rule)
		
		# This is important, otherwise will crash when trying to select
		# again
		old_rule.split_tree.deselect_all()
		
		# Remove all children of meshes
		$Meshes.remove_child(old_rule)
	
	# Create new meshes if the rule is new
	if created:
		var initial_poly = %RuleManager.get_lhs_poly()
		self.poly_to_meshes(initial_poly)

	# Add new meshes
	self.draw_rule()

func _on_symbol_display(symbol, display):
	if symbol != null:
		var symbol_object = %Symbols.get_symbol_object(symbol)
		if not display:
			var parent = symbol_object.get_parent()
			if parent == $Meshes:
				$Meshes.remove_child(symbol_object)
				
		else:
			$Meshes.add_child(symbol_object)
"

[sub_resource type="SphereMesh" id="SphereMesh_4nkvx"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_aipi0"]
resource_name = "red_cursor"
shading_mode = 2
specular_mode = 2
albedo_color = Color(1, 0, 0, 1)

[sub_resource type="GDScript" id="GDScript_r1mpe"]
resource_name = "AddSymbol"
script/source = "extends Button

const symbol_rules = preload(\"res://SymbolRules.tscn\")

func create_symbol(poly, _name=null):
	poly = poly.create_copy()
	poly.center_scale(0.8)
	
	# Symbol handling
	poly.original = true
	poly.order_by_anchor(0, 1)
	var sym = %Symbols.from_polyhedron(poly, false)
	poly.symbol = sym
	
	if _name is String:
		%Symbols.rename(sym, _name)

	var new_symbol_rules = symbol_rules.instantiate()
	new_symbol_rules.symbol = sym
	%SymbolRules.add_child(new_symbol_rules)
	
	# Connect signals
	new_symbol_rules.rule_created.connect(_on_rule_create)
	new_symbol_rules.rule_selected.connect(_on_rule_select)
	new_symbol_rules.rule_deleted.connect(_on_rule_delete)
	
	new_symbol_rules.symbol_renamed.connect(_on_symbol_rename)
	new_symbol_rules.symbol_selected.connect(_on_symbol_select)
	new_symbol_rules.symbol_deleted.connect(_on_symbol_delete)
	
	# Change the ordering of the elements
	var instance_i = new_symbol_rules.get_index()
	%SymbolRules.move_child(new_symbol_rules, instance_i - 1)
	
	%RuleManager.set_to_symbol(sym)

func _pressed():
	# Create a cube for now
	var cube = Cube.new(0.4)
	self.create_symbol(cube)

func _on_rule_create(symbol, index):
	%RuleManager.create_rule(symbol, index)
	
func _on_rule_select(symbol, index):
	%RuleManager.set_to_rule(symbol, index)
	
func _on_rule_delete(symbol, index):
	%RuleManager.remove_rule(symbol, index)
	
func _on_symbol_rename(symbol, new_text):
	%Symbols.rename(symbol, new_text)
	
func _on_symbol_select(symbol):
	%RuleManager.set_to_symbol(symbol)
	
func _on_symbol_delete(symbol):
	%Symbols.delete_symbol(symbol)

"

[sub_resource type="GDScript" id="GDScript_s8l8w"]
resource_name = "ExplorerButton"
script/source = "extends Button

func _pressed():
	%Explorer.visible = not %Explorer.visible
	%Left.collapsed = not %Left.collapsed
	
func get_state():
	return not %Left.collapsed
	
func set_state(state):
	if state:
		self.open()
		
	else:
		self.close()

func open():
	%Explorer.visible = true
	%Left.collapsed = false
	
func close():
	%Explorer.visible = false
	%Left.collapsed = true
"

[node name="Control" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 1

[node name="HSplitContainer" type="HSplitContainer" parent="."]
custom_minimum_size = Vector2(1024, 600)
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="Left" type="VSplitContainer" parent="HSplitContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(750, 0)
layout_mode = 2
size_flags_horizontal = 3

[node name="RuleEditor" type="VSplitContainer" parent="HSplitContainer/Left"]
layout_mode = 2
size_flags_vertical = 3

[node name="ToolOpt" type="HSplitContainer" parent="HSplitContainer/Left/RuleEditor"]
unique_name_in_owner = true
layout_mode = 2
script = ExtResource("1_ac0rl")

[node name="RuleOpt" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolOpt"]
unique_name_in_owner = true
layout_mode = 2

[node name="CompileButton" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolOpt/RuleOpt"]
layout_mode = 2
text = "Compile"
icon = ExtResource("3")
icon_alignment = 2
script = SubResource("GDScript_4jyo7")

[node name="TestGrammar" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolOpt/RuleOpt"]
layout_mode = 2
text = "Test"

[node name="FaceCutOpt" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolOpt"]
visible = false
layout_mode = 2

[node name="GlobalCut" type="CheckButton" parent="HSplitContainer/Left/RuleEditor/ToolOpt/FaceCutOpt"]
layout_mode = 2
text = "Global"

[node name="TriPointCutOpt" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolOpt"]
visible = false
layout_mode = 2

[node name="TestOpt" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolOpt"]
visible = false
layout_mode = 2

[node name="ApplyRule" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolOpt/TestOpt"]
layout_mode = 2
text = "New Gen"

[node name="PrismCutOpt" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolOpt"]
visible = false
layout_mode = 2

[node name="MultiCutOpt" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolOpt"]
visible = false
layout_mode = 2

[node name="SpinBox" type="SpinBox" parent="HSplitContainer/Left/RuleEditor/ToolOpt/MultiCutOpt"]
layout_mode = 2
min_value = 1.0
max_value = 10.0
value = 1.0
suffix = "cuts"
script = SubResource("GDScript_wcrj7")

[node name="ToolsView" type="HSplitContainer" parent="HSplitContainer/Left/RuleEditor"]
layout_mode = 2
collapsed = true
dragger_visibility = 2

[node name="ToolInfo" type="GridContainer" parent="HSplitContainer/Left/RuleEditor/ToolsView"]
unique_name_in_owner = true
visible = false
layout_mode = 2
size_flags_horizontal = 0

[node name="Label" type="Label" parent="HSplitContainer/Left/RuleEditor/ToolsView/ToolInfo"]
layout_mode = 2
text = "Tools"
horizontal_alignment = 1

[node name="FaceCut" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolsView/ToolInfo"]
layout_mode = 2
text = "Face Cut"

[node name="TriPointCut" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolsView/ToolInfo"]
layout_mode = 2
text = "3-Point Cut"

[node name="PrismCut" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolsView/ToolInfo"]
layout_mode = 2
text = "Prism Cut"

[node name="MultiCut" type="Button" parent="HSplitContainer/Left/RuleEditor/ToolsView/ToolInfo"]
layout_mode = 2
text = "Multi Cut"

[node name="SubViewportContainer" type="SubViewportContainer" parent="HSplitContainer/Left/RuleEditor/ToolsView"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
stretch = true
script = ExtResource("2")

[node name="SubViewport" type="SubViewport" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer"]
handle_input_locally = false
physics_object_picking = true
size = Vector2i(840, 376)
render_target_update_mode = 4

[node name="Cam" type="Camera3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport"]
unique_name_in_owner = true
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1.54398)
environment = SubResource("1")

[node name="Root" type="Node3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport"]
script = ExtResource("1")

[node name="RuleManager" type="Node" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root"]
unique_name_in_owner = true
script = SubResource("GDScript_cq0kr")

[node name="TreeManager" type="Node" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/RuleManager"]
script = SubResource("GDScript_xx60u")

[node name="Tester" type="Node3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root"]
visible = false
script = SubResource("GDScript_hr8ly")

[node name="Editor" type="Node3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root"]
unique_name_in_owner = true
script = SubResource("GDScript_besah")

[node name="Selector" type="Node" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor"]
script = ExtResource("4")

[node name="AnchorManager" type="Node" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor"]
script = ExtResource("5")

[node name="Meshes" type="Node3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor"]

[node name="Cursors" type="Node3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor"]
script = ExtResource("6_miobu")

[node name="Cursor1" type="MeshInstance3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor/Cursors"]
transform = Transform3D(0.07, 0, 0, 0, 0.07, 0, 0, 0, 0.07, 0, 0, 0)
visible = false
mesh = SubResource("SphereMesh_4nkvx")
skeleton = NodePath("../..")
surface_material_override/0 = SubResource("StandardMaterial3D_aipi0")

[node name="Cursor2" type="MeshInstance3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor/Cursors"]
transform = Transform3D(0.07, 0, 0, 0, 0.07, 0, 0, 0, 0.07, 0, 0, 0)
visible = false
mesh = SubResource("SphereMesh_4nkvx")
skeleton = NodePath("../..")
surface_material_override/0 = SubResource("StandardMaterial3D_aipi0")

[node name="Cursor3" type="MeshInstance3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root/Editor/Cursors"]
transform = Transform3D(0.07, 0, 0, 0, 0.07, 0, 0, 0, 0.07, 0, 0, 0)
visible = false
mesh = SubResource("SphereMesh_4nkvx")
skeleton = NodePath("../..")
surface_material_override/0 = SubResource("StandardMaterial3D_aipi0")

[node name="Symbols" type="Node" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport/Root"]
unique_name_in_owner = true
script = ExtResource("6_j4m57")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="HSplitContainer/Left/RuleEditor/ToolsView/SubViewportContainer/SubViewport"]
transform = Transform3D(0.656559, 0, 0.754274, 0, 1, 0, -0.754274, 0, 0.656559, 1.85974, 0, 0.65363)
light_energy = 0.3

[node name="ExplorerWindow" type="VSplitContainer" parent="HSplitContainer/Left"]
layout_mode = 2
dragger_visibility = 2

[node name="Explorer" type="TabContainer" parent="HSplitContainer/Left/ExplorerWindow"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3

[node name="Symbols" type="ScrollContainer" parent="HSplitContainer/Left/ExplorerWindow/Explorer"]
custom_minimum_size = Vector2(750, 120)
layout_mode = 2

[node name="SymbolRules" type="GridContainer" parent="HSplitContainer/Left/ExplorerWindow/Explorer/Symbols"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3

[node name="PanelContainer" type="PanelContainer" parent="HSplitContainer/Left/ExplorerWindow/Explorer/Symbols/SymbolRules"]
layout_mode = 2
size_flags_horizontal = 0
size_flags_vertical = 0

[node name="AddSymbol" type="Button" parent="HSplitContainer/Left/ExplorerWindow/Explorer/Symbols/SymbolRules/PanelContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(70, 70)
layout_mode = 2
size_flags_horizontal = 0
size_flags_vertical = 0
text = "New Symbol"
script = SubResource("GDScript_r1mpe")

[node name="PanelContainer" type="PanelContainer" parent="HSplitContainer/Left/ExplorerWindow"]
layout_mode = 2
size_flags_vertical = 8

[node name="HBoxContainer" type="HBoxContainer" parent="HSplitContainer/Left/ExplorerWindow/PanelContainer"]
custom_minimum_size = Vector2(0, 25)
layout_mode = 2

[node name="ExplorerButton" type="Button" parent="HSplitContainer/Left/ExplorerWindow/PanelContainer/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
text = "Symbols"
script = SubResource("GDScript_s8l8w")

[node name="TreeParent" type="VSplitContainer" parent="HSplitContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(300, 0)
layout_mode = 2
